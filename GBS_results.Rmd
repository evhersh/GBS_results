---
title: "GBS_results"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Evan Hersh"
date: "24/06/2019"
output: 
  html_document:
    theme: "readable"
    highlight: "tango"
  
---
```{r dataprocess, include=FALSE, cache=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
knitr::read_chunk("gbs_results.R")
```

```{r echo=FALSE, cache=TRUE, results="hide"}
<<load>>
```


## Assembly, individual missingness and filtering

The assembly was created using only the diploid samples, and with the Yukon population removed (given its apparent distance from the rest of the sexual populations). SNPs were then called on the diploid reference using Freebayes, which is ploidy aware. This generated >400k SNPs, which were whittled down to ~16k SNPs using the following filtering steps:

```
# big filter. This filters based on quality, minor allele count, minor allele frequency, average depth (low and high), excludes indels and SNPs with more than 2 alleles, and removes SNPs that have >5% missing data. 
~/bcftools/bcftools filter TotalRawSNPs.vcf | bcftools filter -e "QUAL < 30 & MQM < 30 & MQMR < 30 || AVG(GQ) < 20 || F_MISSING > 0.05 || MAC < 3 || MAF <0.05 || AVG(FMT/DP)<20 || AVG(FMT/DP)>132.5" | bcftools view --max-alleles 2 --exclude-types indels --output-type v --output-file filter1.vcf

# allele balance
vcffilter -s -f "AB > 0.125 & AB < 0.875 | AB < 0.01" filter1.vcf > filter2.vcf

# SNPs found on both strands
vcffilter -f "SAF / SAR > 100 & SRF / SRR > 100 | SAR / SAF > 100 & SRR / SRF > 100" -s filter2.vcf > filter3.vcf

# ratio of mapping qualities between reference and alternate alleles
vcffilter -f "MQM / MQMR > 0.9 & MQM / MQMR < 1.05" filter3.vcf > filter4.vcf

# discrepancy in properly paired status of reads supporting reference or alternate alleles
vcffilter -f "PAIRED > 0.05 & PAIREDR > 0.05 & PAIREDR / PAIRED < 1.75 & PAIREDR / PAIRED > 0.25 | PAIRED < 0.05 & PAIREDR < 0.05" -s filter4.vcf > filter5.vcf

# ratio of locus quality score to depth
vcffilter -f "QUAL / DP > 0.25" filter5.vcf > final.filtered.snps.vcf
```
Checking for individual missingness after an early filtering step showed this:

![](missingness_before.png)

It's hard to see the names, but two of the samples from C59 (Yukon) and one from B46 have over 30% missingness. We should probably remove those before filtering, because they retain high(ish) missingness even after filtering:

![](missing_after.png)

After removing those three samples and filtering, our SNP count went from 16.2k to 17.1k (so not a huge difference). Here's what it looks like:

![](missing_aftersub.png)

Should we remove these individuals?

## Clone identification

Using poppr, we were able to identify the same number of MLGs as the IBS (from SNPRelate), but automatically and with the full ploidy information. One thing to note is that it grouped the sexual Yukon pop into the same MLG, which makes sense given that they had higher IBS values.

```{r, fig.height=7, fig.width=10, cache=TRUE, echo=FALSE}
<<MLGs>>
```

<br/><br/>

## DAPC

Here's a bunch of DAPC's using different groups / colors.

```{r, fig.height=5, fig.width=8, cache=TRUE, echo=FALSE, fig.cap="Using MS as the two groups (Density plot of PC1)"}
<<DAPC.ms>>
```

<br/><br/>

```{r, fig.height=5, fig.width=8, cache=TRUE, echo=FALSE, fig.cap="Pops as groups, but colored by mating system"}
<<DAPC.popms>>
```

<br/><br/>

```{r, fig.height=5, fig.width=8, cache=TRUE, echo=FALSE, fig.cap="Pops as groups - all pops"}
<<DAPC.popall>>
```

<br/><br/>

```{r, fig.height=5, fig.width=8, cache=TRUE, echo=FALSE, fig.cap="Pops as groups - sub C59-S SM-A C23-A S03-A"}
<<DAPC.popsub>>
```

<br/><br/>

Here's a plot of the posterior membership probabilities:

![](compoplot.png)

## K-means clustering

This is hot off the press. I used a K-means approach from the adegenet package (following this tutorial: http://grunwaldlab.github.io/Population_Genetics_in_R/clustering_plot.html), which uses a clustering algorithm that is similar to STRUCTURE. **Plot A** below is based on 50 runs of the find.clusters algorithm, and shows that ~10-13 clusters have the lowest BIC. **Plot B** is a scatterplot of the discriminant functions (K=10), which helps us see how different the resulting clusters are. **Plot C** shows barplots of the posterior probability group assignments for K = 10-13, which helps visualize how the groups are assigned under different values of K. The K-means results are more-or-less consistent with our other findings, as they assign clones to pretty much the same groups. 

![](kmeans.png)

## MSN

```{r, fig.height=6, fig.width=8, cache=TRUE, echo=FALSE, results="hide"}
<<MSN>>
```

## AMOVA

Here's my first AMOVA run. This uses an `ms/pop` heirarchy. This one is without clone correction:

```{r, fig.height=6, fig.width=8, cache=TRUE, echo=TRUE}
<<AMOVA>>
```

<br/><br/>

Here's the AMOVA with clone correction

```{r, fig.height=6, fig.width=8, cache=TRUE, echo=TRUE}
<<AMOVA.cc>>
```

I don't really know how to interpret this yet...

<!-- <br/><br/> -->

<!-- ## `Poppr` function - genotype richness/diversity/evenness stats -->

<!-- Here are the results from the `poppr` function on the full heirarchy (ms/pop/id): -->

<!-- ```{r, fig.height=6, fig.width=8, cache=TRUE, echo=TRUE} -->
<!-- <<Poppr.ms>> -->
<!-- ``` -->
